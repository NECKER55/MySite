<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Perlin Noise World Generator</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fira+Code:wght@300;400;500;600;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Fira Code', monospace;
            background-color: #0a0a0a;
            color: #b026ff;
            overflow-x: hidden;
            position: relative;
            min-height: 100vh;
        }
        
        /* Scanlines effect */
        body::before {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                transparent 50%,
                rgba(176, 38, 255, 0.03) 50%
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 1;
        }
        
        /* CRT monitor effect */
        body::after {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(
                ellipse at center,
                transparent 0%,
                rgba(0, 0, 0, 0.4) 100%
            );
            pointer-events: none;
            z-index: 2;
        }
        
        /* Terminal container */
        .terminal-container {
            position: relative; 
            padding: 80px;
            min-height: 180vh; 
            z-index: 10;
        }
        
        /* Terminal header */
        .terminal-header {
            display: flex;
            align-items: center;
            margin-bottom: 30px;
            padding: 15px;
            border: 1px solid #b026ff;
            background: rgba(176, 38, 255, 0.05);
            position: relative;
            overflow: hidden;
        }
        
        .terminal-header::before {
            content: "";
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(176, 38, 255, 0.2), transparent);
            animation: scan 8s linear infinite;
        }
        
        @keyframes scan {
            0% { left: -100%; }
            100% { left: 100%; }
        }
        
        .terminal-buttons {
            display: flex;
            gap: 8px;
            margin-right: 20px;
        }
        
        .terminal-button {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .terminal-button.close {
            background: #ff5f56;
            box-shadow: 0 0 10px #ff5f56;
        }
        
        .terminal-button.minimize {
            background: #ffbd2e;
            box-shadow: 0 0 10px #ffbd2e;
        }
        
        .terminal-button.maximize {
            background: #27c93f;
            box-shadow: 0 0 10px #27c93f;
        }
        
        .terminal-button:hover {
            transform: scale(1.2);
        }
        
        .terminal-title {
            position: absolute; 
            left: 50%; 
            transform: translateX(-50%); 
            white-space: nowrap; 
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 3px;
            text-shadow: 0 0 10px #b026ff, 0 0 20px #b026ff;
            z-index: 1; 
            width: fit-content; 
        }
        
        /* Command line */
        .command-line {
            display: flex;
            align-items: baseline; 
            margin-bottom: 20px;
            font-size: 16px;
        }
        
        .prompt {
            color: #00ff00;
            margin-right: 10px;
            text-shadow: 0 0 5px #00ff00;
        }
        
        /* Nuovo stile per l'area di input del comando */
        .command-input-area {
            flex-grow: 1; 
            min-height: 80px; 
            overflow: hidden; 
        }

        .cursor {
            display: inline-block;
            width: 10px;
            height: 20px;
            background: #b026ff;
            animation: blink 1s infinite;
            margin-left: 2px;
            box-shadow: 0 0 10px #b026ff;
        }
        
        @keyframes blink {
            0%, 49% { opacity: 1; }
            50%, 100% { opacity: 0; }
        }
        
        /* Typing text */
        .typing-text {
            display: inline-block; 
            color: #b026ff;
            text-shadow: 0 0 5px #b026ff;
            white-space: pre-wrap; 
        }
        
        /* Output section */
        .output-section {
            margin: 30px 0;
            padding: 20px;
            border-left: 2px solid #b026ff;
            background: rgba(176, 38, 255, 0.02);
            position: relative;
            opacity: 0;
            transform: translateX(-20px);
            animation: slideIn 0.5s ease forwards;
        }
        
        @keyframes slideIn {
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        
        .output-section h2 {
            color: #ff00ff;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 10px #ff00ff, 0 0 20px #ff00ff;
            font-size: 1.5rem;
        }
        
        .output-section p {
            line-height: 1.6;
            margin-bottom: 10px;
            color: #d896ff;
        }

        
        /* Matrix rain effect */
        .matrix-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
            opacity: 0.3; 
        }
        
        /* Interactive menu */
        .menu-section {
            margin: 40px 0;
        }
        
        .menu-item {
            display: block;
            padding: 15px 25px;
            margin: 10px 0;
            border: 1px solid #b026ff;
            background: rgba(176, 38, 255, 0.05);
            color: #b026ff;
            text-decoration: none;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .menu-item::before {
            content: "";
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: rgba(176, 38, 255, 0.2);
            transition: left 0.3s ease;
        }
        
        .menu-item:hover::before {
            left: 0;
        }
        
        .menu-item:hover {
            color: #ff00ff;
            text-shadow: 0 0 10px #ff00ff;
            transform: translateX(10px);
            box-shadow: 0 0 20px rgba(176, 38, 255, 0.5);
        }
        
        .menu-item span {
            position: relative;
            z-index: 1;
        }
        
        /* Loading animation */
        .loading {
            display: inline-block;
            margin: 20px 0;
        }
        
        .loading span {
            display: inline-block;
            width: 10px;
            height: 10px;
            margin: 0 5px;
            background: #b026ff;
            border-radius: 50%;
            animation: loadingDots 1.4s infinite ease-in-out both;
            box-shadow: 0 0 10px #b026ff;
        }
        
        .loading span:nth-child(1) { animation-delay: -0.32s; }
        .loading span:nth-child(2) { animation-delay: -0.16s; }
        
        @keyframes loadingDots {
            0%, 80%, 100% {
                transform: scale(0);
                opacity: 0.5;
            }
            40% {
                transform: scale(1);
                opacity: 1;
            }
        }
        
        /* Progress bar */
        .progress-container {
            width: 100%;
            height: 20px;
            background: rgba(176, 38, 255, 0.1);
            border: 1px solid #b026ff;
            margin: 20px 0;
            position: relative;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #b026ff, #ff00ff);
            width: 0%;
            animation: progress 3s ease-in-out forwards;
            box-shadow: 0 0 20px #b026ff;
        }
        
        @keyframes progress {
            to { width: 100%; }
        }
        
        .progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 12px;
            font-weight: bold;
            text-shadow: 0 0 5px #000;
        }
        
        /* Glitch text effect */
        .glitch-text {
            position: relative;
            font-size: 3rem;
            font-weight: bold;
            text-transform: uppercase;
            text-align: center;
            margin: 40px 0; 
            color: #b026ff;
            text-shadow: 0 0 20px #b026ff;
        }
        
        .glitch-text::before,
        .glitch-text::after {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .glitch-text::before {
            animation: glitchEffect 0.3s infinite;
            color: #ff00ff;
            z-index: -1;
        }
        
        .glitch-text::after {
            animation: glitchEffect 0.3s infinite reverse;
            color: #00ffff;
            z-index: -2;
        }
        
        @keyframes glitchEffect {
            0% {
                text-shadow: 0.05em 0 0 #ff00ff;
                transform: translateX(0);
            }
            100% {
                text-shadow: -0.05em 0 0 #00ffff;
                transform: translateX(0.05em);
            }
        }

        /* Nuovo contenitore per il blocco principale (con margin-top di 200px) */
        #main-content-block {
            margin-top: 550px; 
        }
        
        /* Globe Container */
        .globe-container {
            position: absolute; 
            top: 500px; /* Posizione rispetto al suo genitore con position: relative */
            right: 50px; 
            width: 300px; 
            height: 300px; 
            z-index: 100;
            background: transparent; 
            border: none; 
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .globe-header {
            font-size: 15px;
            color: #b026ff;
            text-align: center;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        #globeCanvas2D {
            display: block;
            background-color: transparent;
            width: 200px; 
            height: 200px; 
        }

        /* Nuovo stile per il pulsante portfolio */
        .portfolio-button {
            color: #b026ff; 
            text-decoration: none;
            border: 1px solid #b026ff;
            padding: 5px 10px;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-right: 20px; 
            transition: all 0.3s ease;
            box-shadow: 0 0 10px rgba(176, 38, 255, 0.5);
            position: relative;
            overflow: hidden;
            z-index: 1; 
        }

        .portfolio-button::before {
            content: "";
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: rgba(176, 38, 255, 0.1);
            transition: left 0.3s ease;
            z-index: -1;
        }

        .portfolio-button:hover::before {
            left: 0;
        }

        .portfolio-button:hover {
            color: #fff;
            text-shadow: 0 0 5px #b026ff;
            box-shadow: 0 0 20px rgba(176, 38, 255, 0.5);
        }
        
        /* Stili per l'icona GitHub - ORA SI MUOVE CON IL RESTO DELLA PAGINA */
        .github-link-container {
            position: absolute; /* Cambiato da fixed a absolute */
            top: 400px; /* Posizionamento all'interno del contenitore scorrevole */
            left: 50%;
            transform: translateX(-50%); /* Centering orizzontale */
            z-index: 1000; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            padding: 10px; 
        }

        .github-link-header {
            font-size: 15px; 
            color: #b026ff;
            text-align: center;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .github-icon {
            font-size: 60px; 
            color: #b026ff; 
            text-decoration: none;
            transition: all 0.3s ease;
            text-shadow: 0 0 15px #b026ff; 
        }

        .github-icon:hover {
            color: #ff00ff; 
            transform: scale(1.1); 
            text-shadow: 0 0 25px #ff00ff; 
        }

        /* Perlin Noise Visualization Styles */
        .perlin-canvas {
            display: none;
            width: 100%;
            max-width: 800px;
            height: 400px;
            border: 2px solid #b026ff;
            margin: 20px auto;
            background: #000;
            box-shadow: 0 0 30px rgba(176, 38, 255, 0.5);
        }

        .world-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .stat-box {
            padding: 15px;
            border: 1px solid #b026ff;
            background: rgba(176, 38, 255, 0.05);
            text-align: center;
        }

        .stat-box h3 {
            color: #ff00ff;
            margin-bottom: 10px;
            font-size: 1.2rem;
        }

        .stat-box p {
            color: #b026ff;
            font-size: 2rem;
            font-weight: bold;
            text-shadow: 0 0 10px currentColor;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .terminal-container {
                padding: 20px;
            }
            
            .glitch-text {
                font-size: 2rem;
            }
            
            .globe-container {
                width: 120px; 
                height: 120px;
                top: 150px; 
                right: 10px;
            }
            
            #globeCanvas2D {
                width: 100px; 
                height: 100px;
            }

            .portfolio-button {
                font-size: 10px;
                padding: 3px 8px;
                margin-right: 10px;
            }

            .github-icon {
                font-size: 40px; 
            }

            .github-link-header {
                font-size: 12px;
            }
        }
        /* Responsive - Mobile First Approach */
        @media (max-width: 768px) {
            body {
                overflow-x: hidden;
                min-height: 100vh;
            }

            .terminal-container {
                padding: 10px;
                min-height: 100vh;
            }
            
            /* Terminal header mobile */
            .terminal-header {
                padding: 10px;
                margin-bottom: 20px;
                flex-wrap: wrap;
                justify-content: space-between;
            }
            
            .terminal-title {
                font-size: 10px;
                letter-spacing: 1px;
                position: static;
                transform: none;
                margin-top: 10px;
                order: 3;
                width: 100%;
                text-align: center;
            }
            
            .portfolio-button {
                font-size: 10px;
                padding: 5px 10px;
                margin-right: 0;
                order: 1;
            }
            
            .terminal-buttons {
                order: 2;
            }
            
            /* Command line mobile */
            .command-line {
                font-size: 12px;
                margin-bottom: 15px;
            }
            
            .command-input-area {
                min-height: 40px;
            }
            
            .typing-text {
                font-size: 12px;
            }
            
            .cursor {
                height: 15px;
                width: 8px;
            }
            
            /* Main content adjustment */
            #main-content-block {
                margin-top: 250px;
            }
            
            /* Glitch text mobile */
            .glitch-text {
                font-size: 1.5rem;
                margin: 20px 0;
                word-break: break-word;
            }
            
            /* Globe container mobile - moved to bottom right corner */
            .globe-container {
                position: absolute;
                bottom: 520px;
                right: 10px;
                top: auto;
                width: 80px;
                height: 80px;
                z-index: 999;
                background: rgba(10, 10, 10, 0.8);
                border-radius: 10px;
                padding: 5px;
            }
            
            .globe-header {
                font-size: 10px;
                letter-spacing: 1px;
                margin-bottom: 2px;
            }
            
            #globeCanvas2D {
                width: 60px;
                height: 60px;
            }
            
            /* GitHub link mobile - centered at top */
            .github-link-container {
                position: relative;
                bottom: 20px;
                left: 10px;
                top: auto;
                transform: none;
                z-index: 999;
                background: rgba(10, 10, 10, 0);
                border-radius: 10px;
                padding: 5px;
                width: 80px;
                height: 14px;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
            }
            
            .github-link-header {
                font-size: 10px;
                letter-spacing: 1px;
                margin-bottom: 0px;
            }
            
            .github-icon {
                font-size: 55px;
            }
            
            /* Menu items mobile */
            .menu-item {
                padding: 12px 15px;
                margin: 8px 0;
                font-size: 11px;
                letter-spacing: 1px;
            }
            
            /* Output sections mobile */
            .output-section {
                padding: 15px;
                margin: 20px 0;
            }
            
            .output-section h2 {
                font-size: 1.1rem;
                margin-bottom: 10px;
            }
            
            .output-section p {
                font-size: 12px;
                line-height: 1.5;
                margin-bottom: 8px;
            }
            
            /* Progress bar mobile */
            .progress-container {
                height: 15px;
                margin: 15px 0;
            }
            
            .progress-text {
                font-size: 10px;
            }
            
            /* World stats mobile */
            .world-stats {
                grid-template-columns: 1fr;
                gap: 10px;
                margin: 15px 0;
            }
            
            .stat-box {
                padding: 10px;
            }
            
            .stat-box h3 {
                font-size: 0.9rem;
                margin-bottom: 5px;
            }
            
            .stat-box p {
                font-size: 1.5rem;
            }
            
            /* Perlin canvas mobile */
            .perlin-canvas {
                width: 100%;
                height: 200px;
                margin: 15px auto;
            }
            
            /* Loading dots mobile */
            .loading span {
                width: 8px;
                height: 8px;
                margin: 0 3px;
            }
            
            /* Reduce matrix effect on mobile for performance */
            #matrixCanvas {
                opacity: 0.2;
            }
        }

        /* Extra small devices */
        @media (max-width: 480px) {
            .terminal-container {
                padding: 5px;
            }
            
            .glitch-text {
                font-size: 1.2rem;
            }
            
            .menu-item {
                padding: 10px 12px;
                font-size: 10px;
            }
            
            .output-section p {
                font-size: 11px;
            }
            
            /* Hide portfolio button on very small screens to save space */
            .portfolio-button {
                z-index: 1000;
            }
            
            /* Adjust github position for very small screens */
            .github-link-container {
                top: 150px;
            }
            
            #main-content-block {
                margin-top: 200px;
            }
        }

        /* Touch-friendly adjustments */
        @media (hover: none) and (pointer: coarse) {
            .menu-item {
                padding: 15px 20px;
                margin: 12px 0;
            }
            
            .terminal-button {
                width: 15px;
                height: 15px;
            }
            
            /* Disable hover effects on touch devices */
            .menu-item:hover {
                transform: none;
            }
            
            .menu-item:active {
                transform: translateX(5px);
                background: rgba(176, 38, 255, 0.2);
            }
        }

        /* Landscape orientation adjustments */
        @media (max-width: 768px) and (orientation: landscape) {
            .terminal-container {
                padding: 10px 20px;
            }
            
            #main-content-block {
                margin-top: 150px;
            }
            
            .glitch-text {
                font-size: 1.3rem;
                margin: 15px 0;
            }
            
            .globe-container {
                bottom: 10px;
                right: 5px;
                width: 60px;
                height: 60px;
            }
            
            #globeCanvas2D {
                width: 50px;
                height: 50px;
            }
            
            .github-link-container {
                top: 120px;
            }
            
            .perlin-canvas {
                height: 150px;
            }
        }
    </style>
</head>
<body>
    <canvas class="matrix-bg" id="matrixCanvas"></canvas>
    
    <div class="terminal-container">
        <div class="terminal-header">
            <a href="index.html" class="portfolio-button">Portfolio</a>
            <div class="terminal-buttons">
                <div class="terminal-button close"></div>
                <div class="terminal-button minimize"></div>
                <div class="terminal-button maximize"></div>
            </div>
            <div class="terminal-title">Perlin Noise World Generator v1.0</div>
        </div>
        
        <div class="command-line">
            <span class="prompt">user@Mac:~$</span>
            <div class="command-input-area"> 
                <span class="typing-text" id="typingText"></span>
                <span class="cursor"></span>
            </div>
        </div>
        
        <div class="github-link-container">
            <div class="github-link-header">Source Code</div>
            <a href="https://github.com/NECKER55/procedural_map.git" target="_blank" class="github-icon" title="View Source Code">
                <i class="fab fa-github"></i>
            </a>
        </div>

        <div class="globe-container">
            <div class="globe-header">CONNECTED</div>
            <canvas id="globeCanvas2D" width="120" height="120"></canvas>
        </div>
        
        <div id="main-content-block">
            <h1 class="glitch-text" data-text="PERLIN NOISE WORLD GENERATOR">PERLIN NOISE WORLD GENERATOR</h1>
            
            <div class="progress-container">
                <div class="progress-bar"></div>
                <span class="progress-text">Initializing Perlin Engine...</span>
            </div>
            
            <div class="menu-section">
                <div class="output-section" style="animation-delay: 1s;">
                    <h2>System Commands</h2>
                    <a href="#" class="menu-item" onclick="executeCommand('algorithm'); return false;">
                        <span>[1] Perlin Algorithm Explanation</span>
                    </a>
                    <a href="#" class="menu-item" onclick="executeCommand('generate'); return false;">
                        <span>[2] Generate Perlin Noise Map</span>
                    </a>
                    <a href="#" class="menu-item" onclick="executeCommand('world'); return false;">
                        <span>[3] Create 3D World</span>
                    </a>
                    <a href="#" class="menu-item" onclick="executeCommand('minerals'); return false;">
                        <span>[4] Mineral Distribution Analysis</span>
                    </a>
                    <a href="#" class="menu-item" onclick="executeCommand('visualize'); return false;">
                        <span>[5] Live Visualization</span>
                    </a>
                </div>
            </div>
            
            <div id="dynamicOutput"></div>
            <canvas id="perlinCanvas" class="perlin-canvas"></canvas>
        </div>
    </div>
    
    <script>
        // Matrix rain effect with reduced intensity
        const canvas = document.getElementById('matrixCanvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        const characters = '01アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲン';
        const charArray = characters.split('');
        const fontSize = 14;
        const columns = canvas.width / fontSize;
        const drops = [];

        let currentAnimationId = null; // Variabile per memorizzare l'ID del frame di animazione
        
        for (let i = 0; i < columns; i++) {
            drops[i] = Math.floor(Math.random() * -canvas.height / fontSize); 
        }
        
        function drawMatrix() {
            ctx.fillStyle = 'rgba(10, 10, 10, 0.05)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#b026ff';
            ctx.font = `${fontSize}px monospace`;
            
            for (let i = 0; i < drops.length; i++) {
                const text = charArray[Math.floor(Math.random() * charArray.length)];
                const x = i * fontSize;
                const y = drops[i] * fontSize;
                
                const gradient = ctx.createLinearGradient(0, y - fontSize * 5, 0, y);
                gradient.addColorStop(0, 'rgba(176, 38, 255, 0)');
                gradient.addColorStop(0.5, 'rgba(176, 38, 255, 0.3)');
                gradient.addColorStop(1, 'rgba(176, 38, 255, 0.6)');
                
                ctx.fillStyle = gradient;
                ctx.fillText(text, x, y);
                
                if (y > canvas.height) {
                    drops[i] = 0; 
                }
                
                drops[i]++; 
            }
        }
        
        setInterval(drawMatrix, 50);
        
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            for (let i = 0; i < columns; i++) {
                drops[i] = Math.floor(Math.random() * -canvas.height / fontSize); 
            }
        });
        
        // 2D Globe Animation
        const globeCanvas2D = document.getElementById('globeCanvas2D');
        const globeCtx = globeCanvas2D.getContext('2d');

        const globeRadius = globeCanvas2D.width / 2 - 5;
        const globeCenterX = globeCanvas2D.width / 2;
        const globeCenterY = globeCanvas2D.height / 2;
        const numPoints = 200;
        const points = [];
        let rotationAngle = 0;

        for (let i = 0; i < numPoints; i++) {
            const lat = Math.acos(2 * Math.random() - 1);
            const lon = 2 * Math.PI * Math.random();
            
            const x = globeRadius * Math.sin(lat) * Math.cos(lon);
            const y = globeRadius * Math.sin(lat) * Math.sin(lon);
            const z = globeRadius * Math.cos(lat);

            points.push({ x, y, z });
        }

        function drawGlobe2D() {
            globeCtx.clearRect(0, 0, globeCanvas2D.width, globeCanvas2D.height);
            globeCtx.fillStyle = '#b026ff'; 

            rotationAngle += 0.02;

            for (let i = 0; i < points.length; i++) {
                const p = points[i];

                const rotatedX = p.x * Math.cos(rotationAngle) - p.z * Math.sin(rotationAngle);
                const rotatedZ = p.x * Math.sin(rotationAngle) + p.z * Math.cos(rotationAngle);

                const projectedX = rotatedX + globeCenterX;
                const projectedY = p.y + globeCenterY;

                const scale = 1 - (rotatedZ / (2 * globeRadius));
                const opacity = 0.5 + (rotatedZ / (2 * globeRadius)) * 0.5;

                globeCtx.globalAlpha = opacity;
                globeCtx.beginPath();
                globeCtx.arc(projectedX, projectedY, 1.5 * scale, 0, Math.PI * 2);
                globeCtx.fill();
            }
             globeCtx.globalAlpha = 1;
        }

        setInterval(drawGlobe2D, 50);

        // Typing effect
        const typingElement = document.getElementById('typingText');
        const commands = [
            'loading perlin_noise.go...',
            'hi my fellow coder, welcome to the perlin noise world generator.',
            'are you smart?',
            "01101000 01100101 01101100 01101100 01101111 00101110 (That's 'hello' in binary, just in case you were wondering.)",
            "why are you still here? i'm tired of typing...",
            '01100101 01110110 01100101 01110010 01111001 00100000 01110011 01100101 01100011 01101111 01101110 01100100 00100000 01101101 01101111 01110010 01100101 00100000 01100100 01100001 01101110 01100111 01100101 01110010 01101111 01110101 01110011 01101100 01111001 00100000 01110000 01110010 01100101 01110000 01100001 01110010 01100101 01100100 00100000 01110100 01101000 01100001 01101110 00100000 01100010 01100101 01100110 01101111 01110010 01100101',
        ];
        
        let commandIndex = 0;
        let charIndex = 0;
        let isDeleting = false;
        
        function typeCommand() {
            const currentCommand = commands[commandIndex];
            
            if (!isDeleting) {
                typingElement.textContent = currentCommand.substring(0, charIndex);
                charIndex++;
                
                if (charIndex > currentCommand.length) {
                    isDeleting = true;
                    setTimeout(typeCommand, 2000);
                    return;
                }
            } else {
                typingElement.textContent = currentCommand.substring(0, charIndex);
                charIndex--;
                
                if (charIndex === 0) {
                    isDeleting = false;
                    commandIndex = (commandIndex + 1) % commands.length;
                }
            }
            
            const typingSpeed = isDeleting ? 50 : 100;
            setTimeout(typeCommand, typingSpeed);
        }
        
        typeCommand();

        // Perlin Noise Implementation
        class PerlinNoise {
            constructor(width, height, scale) {
                this.width = width;
                this.height = height;
                this.scale = scale;
                this.gradients = {};
                this.memory = {};
            }

            dot(g, x, y) {
                return g[0] * x + g[1] * y;
            }

            randomGradient(ix, iy) {
                const random = Math.sin(ix * 12.9898 + iy * 78.233) * 43758.5453123;
                const angle = random * 2 * Math.PI;
                return [Math.cos(angle), Math.sin(angle)];
            }

            getGradient(x, y) {
                const key = `${x},${y}`;
                if (!this.gradients[key]) {
                    this.gradients[key] = this.randomGradient(x, y);
                }
                return this.gradients[key];
            }

            smoothstep(t) {
                return t * t * (3 - 2 * t);
            }

            perlin(x, y) {
                const x0 = Math.floor(x);
                const x1 = x0 + 1;
                const y0 = Math.floor(y);
                const y1 = y0 + 1;

                const sx = this.smoothstep(x - x0);
                const sy = this.smoothstep(y - y0);

                const g00 = this.getGradient(x0, y0);
                const g10 = this.getGradient(x1, y0);
                const g01 = this.getGradient(x0, y1);
                const g11 = this.getGradient(x1, y1);

                const n00 = this.dot(g00, x - x0, y - y0);
                const n10 = this.dot(g10, x - x1, y - y0);
                const n01 = this.dot(g01, x - x0, y - y1);
                const n11 = this.dot(g11, x - x1, y - y1);

                const nx0 = n00 * (1 - sx) + n10 * sx;
                const nx1 = n01 * (1 - sx) + n11 * sx;

                return nx0 * (1 - sy) + nx1 * sy;
            }

            generate() {
                const data = [];
                for (let y = 0; y < this.height; y++) {
                    data[y] = [];
                    for (let x = 0; x < this.width; x++) {
                        const value = this.perlin(x * this.scale, y * this.scale);
                        data[y][x] = (value + 1) / 2; // Normalize to 0-1
                    }
                }
                return data;
            }
        }

        // Command execution
       function executeCommand(cmd) {
            const output = document.getElementById('dynamicOutput');
            const perlinCanvas = document.getElementById('perlinCanvas');
            output.innerHTML = ''; // Pulisce il contenuto testuale dinamico

            // 1. Nasconde sempre il canvas all'inizio di ogni comando
            if (perlinCanvas) { 
                perlinCanvas.style.display = 'none';
            }

            // 2. Interrompe qualsiasi animazione precedente del canvas
            if (currentAnimationId) {
                cancelAnimationFrame(currentAnimationId);
                currentAnimationId = null; // Resetta l'ID dell'animazione
            }

            const newSection = document.createElement('div');
            newSection.className = 'output-section';
            newSection.style.animationDelay = '0s'; // Reset animation delay for immediate appearance

            switch(cmd) {
                case 'algorithm':
                    newSection.innerHTML = `
                        <h2>Perlin Noise Algorithm</h2>
                        <p>> <strong>Grid System:</strong> The world is divided into a 10x10 grid, with each slot containing 10x10 pixels</p>
                        <p>> <strong>Gradient Vectors:</strong> Random unit vectors are placed at each grid vertex</p>
                        <p>> <strong>Dot Product:</strong> For each pixel, calculate dot products with the 4 surrounding gradient vectors</p>
                        <p>> <strong>Interpolation:</strong> Use bilinear interpolation to smooth values between grid points</p>
                        <p>> <strong>Smoothstep Function:</strong> Apply 3t²-2t³ for smoother transitions</p>
                        <p>> <strong>Height Mapping:</strong> Values range from -9 to +9, creating realistic terrain elevation</p>
                        <p>> <strong>3D Extension:</strong> Stack 2D noise maps to create volumetric terrain with 70 layers</p>
                        <p>> <strong>Optimization:</strong> Uses memoization to cache gradient calculations</p>
                    `;
                    // `output.appendChild(newSection);` per questo caso è gestito dopo lo switch
                    break;
                    
                case 'generate':
                    newSection.innerHTML = `
                        <h2>Generating Perlin Noise Map</h2>
                        <div class="loading">
                            <span></span>
                            <span></span>
                            <span></span>
                        </div>
                    `;
                    output.appendChild(newSection); // Appende la sezione di caricamento subito
                    
                    setTimeout(() => {
                        generatePerlinVisualization(); // Questa funzione disegnerà la mappa sul canvas
                        // 3. Sostituisce l'innerHTML per rimuovere i puntini di caricamento dopo il calcolo
                        newSection.innerHTML = `<div class="output-subtext">Here's an example of a 2D perlin map.</div>`;
                        newSection.scrollIntoView({ behavior: 'smooth', block: 'center' }); // Scorri dopo che il contenuto è cambiato
                    }, 1500); // Simula il tempo di calcolo
                    break;
                    
                case 'world':
                    newSection.innerHTML = `
                        <h2>3D World Generation</h2>
                        <p>> I use this algorithm to create the terrain differences in a minecraft world, also these are the characteristics of the world..</p>
                        <p>> Creating world array[70][100][100]...</p>
                        <p>> Layer 0: Bedrock (indestructible)</p>
                        <p>> Layers 1-40: Stone with mineral veins</p>
                        <p>> Layers 41-70: Dirt and air based on height map</p>
                        <p>> There is an algorithm that takes care of this generation (Vein Generation Algorithm)</p>
                        <div class="world-stats">
                            <div class="stat-box">
                                <h3>Total Blocks</h3>
                                <p>700,000</p>
                            </div>
                            <div class="stat-box">
                                <h3>World Size</h3>
                                <p>100x100x70</p>
                            </div>
                            <div class="stat-box">
                                <h3>Biomes</h3>
                                <p>Procedural</p>
                            </div>
                        </div>
                    `;
                    // `output.appendChild(newSection);` per questo caso è gestito dopo lo switch
                    break;
                    
                case 'minerals':
                    newSection.innerHTML = `
                        <h2>Mineral Distribution System</h2>
                        <p>> <strong>Vein Generation Algorithm:</strong></p>
                        <p>  • Coal: 13% chance, max 20 blocks/vein, layers 2-40</p>
                        <p>  • Iron: 8% chance, max 15 blocks/vein, layers 2-40</p>
                        <p>  • Gold: 5% chance, max 10 blocks/vein, layers 2-30</p>
                        <p>  • Diamond: 3% chance, max 5 blocks/vein, layers 2-15</p>
                        <p>> <strong>Vein Continuity:</strong> Uses recursive checking within 5-block radius</p>
                        <p>> <strong>Realistic Distribution:</strong> Minerals cluster naturally using probability weights</p>
                    `;
                    // `output.appendChild(newSection);` per questo caso è gestito dopo lo switch
                    break;
                    
                case 'visualize':
                    newSection.innerHTML = `
                        <h2>Live Perlin Noise Visualization</h2>
                        <p>> This visualization represents a continuously evolving cross-section or "slice" of Perlin's noise. Imagine a vast, undulating three-dimensional landscape or a complex atmospheric phenomenon. This visualization offers a glimpse into how that landscape can be generated, constantly changing yet very close to a real situation.</p>
                    `;
                    output.appendChild(newSection); // Appende la sezione di caricamento subito
                    if (perlinCanvas) {
                        perlinCanvas.style.display = 'block'; // Mostra il canvas
                    }
                    animatePerlinNoise(); // Avvia l'animazione
                    // Non c'è bisogno di setTimeout per un messaggio "completo" qui,
                    // dato che è una visualizzazione "live" e il messaggio di caricamento iniziale è sufficiente.
                    break;
                    
                case 'clear':
                    output.innerHTML = '<div class="output-section">Terminal cleared.</div>';
                    if (perlinCanvas) {
                        perlinCanvas.style.display = 'none'; // Assicurati che il canvas sia nascosto anche qui
                    }
                    break;

                default:
                    newSection.innerHTML = `
                        <h2>Command Not Found</h2>
                        <p>> Unknown command: ${cmd}</p>
                    `;
                    // `output.appendChild(newSection);` per questo caso è gestito dopo lo switch
            }
            
            // Questa logica gestisce l'aggiunta della newSection per i casi in cui non è già stata appesa
            // (come 'algorithm', 'world', 'minerals', 'default') e lo scroll per questi casi.
            if (cmd !== 'generate' && cmd !== 'visualize' && cmd !== 'clear') {
                output.appendChild(newSection);
                newSection.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
            // Per 'generate', 'visualize' e 'clear', lo scroll è gestito all'interno del case specifico o non necessario.
        }

        function generatePerlinVisualization() {
            const canvas = document.getElementById('perlinCanvas');
            const ctx = canvas.getContext('2d');
            canvas.style.display = 'block';
            canvas.width = 800;
            canvas.height = 400;
            
            const perlin = new PerlinNoise(100, 100, 0.1);
            const noiseData = perlin.generate();
            
            // Draw the noise map
            for (let y = 0; y < 100; y++) {
                for (let x = 0; x < 100; x++) {
                    const value = noiseData[y][x];
                    const height = Math.floor((value * 18) - 9); // Convert to -9 to +9 range
                    
                    let color;
                    if (height < -5) {
                        color = `rgb(0, 0, ${100 + height * 10})`; // Deep blue
                    } else if (height < 0) {
                        color = `rgb(0, ${100 + height * 20}, 0)`; // Green
                    } else if (height < 5) {
                        color = `rgb(${150 + height * 10}, ${150 + height * 5}, 0)`; // Yellow
                    } else {
                        color = `rgb(${200 + height * 5}, ${200 + height * 5}, ${200 + height * 5})`; // White
                    }
                    
                    ctx.fillStyle = color;
                    ctx.fillRect(x * 8, y * 4, 8, 4);
                }
            }
            
            // Add grid overlay
            ctx.strokeStyle = 'rgba(176, 38, 255, 0.2)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                ctx.beginPath();
                ctx.moveTo(i * 80, 0);
                ctx.lineTo(i * 80, 400);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(0, i * 40);
                ctx.lineTo(800, i * 40);
                ctx.stroke();
            }
        }

        function animatePerlinNoise() {
            const canvas = document.getElementById('perlinCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 800;
            canvas.height = 400;
            canvas.style.display = 'block';

            let offset = 0;

            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height); // Pulisce il canvas
                ctx.fillStyle = 'rgba(10, 10, 10, 0.1)'; // Colore di sfondo per l'effetto dissolvenza
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.lineWidth = 1;
                ctx.strokeStyle = '#b026ff';

                for (let z = 0; z < 20; z++) {
                    ctx.beginPath();
                    ctx.globalAlpha = 1 - (z / 20);

                    for (let x = 0; x < canvas.width; x += 5) {
                        const perlin = new PerlinNoise(100, 100, 0.1); // Rimuovi la ricreazione dell'istanza in loop, dovresti crearla una volta fuori dal loop animate o gestirla diversamente per performance
                        const noiseValue = perlin.perlin((x / 100) + offset, (z / 10) + offset);
                        const y = canvas.height / 2 + noiseValue * 100 - z * 10;

                        if (x === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.stroke();
                }

                ctx.globalAlpha = 1;
                offset += 0.01;

                // MODIFICA QUI: Salva l'ID dell'animazione
                currentAnimationId = requestAnimationFrame(animate);
            }
            animate();
        }
        
        // Add random glitch effects
        setInterval(() => {
            if (Math.random() > 0.95) {
                const elements = document.querySelectorAll('.output-section, .menu-item');
                const randomElement = elements[Math.floor(Math.random() * elements.length)];
                if (randomElement) {
                    randomElement.style.transform = `translateX(${Math.random() * 4 - 2}px)`;
                    setTimeout(() => {
                        randomElement.style.transform = '';
                    }, 100);
                }
            }
        }, 1000);
    </script>
</body>
</html>